# 함수형 자바스크립트, 루이스 아텐시오 내용정리

## 1장 함수형 길들이기
* 이 장에서 다루는 내용들
  * 함수형 사고방식
  * 함수형 프로그래밍의 정의와 필요성
  * 불변성, 순수함수 원리
  * 함수형 프로그래밍 기법 및 그것이 설계 전반에 미치는 영향

* 복잡성의 증가
  * 현재 웹과 관련된 JS진영은 과거와 달리 복잡성이 크게 증가
  * 대규모 서버 애플리케이션, 대부분의 비즈니스 로직을 클라이언트 측에 두기가 기술적으로 가능
  * 여러 저장소와 통신하며 비동기 작업을 생성하고 이벤트를 처리하는 등 다양한 기술이 필요해짐
  
* 함수형 프로그래밍
  * 이런 복잡성들은 객체지향 방식으로도 해결 가능
  * 하지만 자바스크립트는 상태 공유가 보편적이라 관리하기 어려운 코드가 되기 쉬움
  * 최근 리액티브 프로그래밍의 유행도 데이터흐름과 변경 전파의 중요성을 반증
  * 데이터와 데이터를 다루는 함수에 대해 진지하게 고민하는 패러다임의 필요성 대두

* 애플리케이션의 필수 설계 요소
  1. 확장성 : 추가 기능 지원을 위해 계속 리팩토링이 필요한가
  2. 모듈화 용이성 : 파일 하나를 고치면 다른 파일도 영향을 받는가
  3. 재사용성 : 중복이 많은가
  4. 테스트성 : 함수를 단위 테스트하기 어려운가
  5. 헤아리기 쉬움 : 체계도 없고 따라가기 어려운 코드인가
  * 함수형은 특정 API가 아닌 위의 문제들을 해결하려는 하나의 패러다임이다

### 1.1 함수형 프로그래밍은 과연 유용한가?
* 자바스크립트의 단점 보완
  * FP는 깔끔하고 모듈화하기 좋으며 테스트가 쉬운 간결한 JS코드 작성에 도움이 된다
  * JS는 상태관리를 개발자에 떠넘기는 동적인 언어이므로 버그를 양산해왔다
  * JS코드를 함수형으로 작성하면 대부분의 문제가 해결된다
  * 순수함수로 구현한 코드는 전역상태를 깨뜨리지 않아 복잡하고 거대한 앱도 통제가 쉽다
  * 따라서 전체 애플리케이션 품질도 향상시키며 동시에 JS자체의 이해도 증진시킨다

### 1.2 함수형 프로그래밍 
* 정확한 개념 정의의 중요성
  * FP는 함수 사용을 강조하는 개발 패러다임
  * 많은 사람들은 과거에 함수를 사용해온 경험을 말하며 차이점이 무엇인지 인식하기 어려워함
  * 함수형의 진짜 목표
    * 부수효과(Side effect)를 방지하고 상태 변이(Mutation of state)를 감소시키기 위해
    * 데이터의 제어 흐름과 연산을 추상(abstract)화하는 것이다

* 간단한 예제로 시작하기
  ~~~
  <body> // 이후 코드에선 body 태그 생략
    <div id="msg"></div>
    <script>
      document.querySelector('#msg').innerHTML = '<h1>Hello World</h1>';
    </script>
  </body>
  ~~~
  * 이 예제는 하드코딩되어서 메시지를 동적으로 표시할 수 없다

  ~~~
  function printMessage(elementId, format, message) {
      document.querySelector(`#${elementId}`).innerHTML =
          `<${format}>${message}</${format}>`;
  }

  printMessage('msg', 'h1', 'Hello World');
  ~~~
  * 재사용가능한 코드가 되었으나 HTML이 아닌 다른 형식에 사용할 수 없어(ex. 파일) 완벽하지 않다
  * 이 문제를 해결하려면 특정 기능을 함수에 추가해 매개변수로 전달하는  함수의 매개변수화가 필요
  * FP에서는 여러 함수를 서로 합성해 더 많은 기능을 탑재해야 한다

  ~~~
  var printMessage = run(addToDom('msg'), h1, echo);
  printMessage('Hello World');
  ~~~
  * h1은 스칼라 값이 아닌 addToDom ,echo와 같은 함수가 되었다
  * 이와 같이 FP에서는 작은 함수들을 재료로 새로운 함수로 만들어낸다
  * FP에서는 더 작은 조각들로 프로그램을 나눈 후 더 쉬운 형태로 다시 조합하는 과정을 거친다
  * run 함수는 addToDom, h1, echo 함수를 연결해 한 함수의 반환값을 다른 함수의 입력으로 전달
  * echo함수가 Hello World를 반환하면 h1에 전달되고, h1의 결과값이 addToDom에 전달되는 구조다

  ~~~
  var printMessage = run(console.log, repeat(2), h1, echo);
  printMessage('Get Functional');
  ~~~
  * 앞선 코드들의 흐름을 익히면 위 코드의 흐름을 예측하는 것이 어렵지 않다
  * 이처럼 시각적인 명료함은 우연의 산물이 아니다
  * FP는 FP가 아닌 코드와 근본적으로 스타일이 다르다
  * 이는 FP 특유의 선언적 개발 방식 때문이다
  * 이를 온전히 이해하려면 다음과 같은 개념을 숙지해야 한다
    * 선언적 프로그래밍
    * 순수함수
    * 참조 투명성
    * 불변성

### 1.2.1 함수형 프로그래밍은 선언적(declarative) 
* 선언적이라는 말은 내부 구현과 데이터 흐름을 감추고 연산/작업을 표현하는 사상을 의미한다
* 기존의 익숙한 방식은 명령형(imperative) 또는 절차적(procedural) 방식
  * 특정 결과를 위해 시스템의 상태를 변경하는 구문을 위에서 아래로 늘어놓는 수열방식
  ~~~
  // 명령형 또는 절차적 방식의 코드의 예(배열의 모든 원소 제곱)
  var array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    for(let i = 0; i < array.length; i++) {
        array[i] = Math.pow(array[i], 2);
    }
  console.log(array);
  ~~~
* 선언적 프로그래밍은 서술부(description)와 평가부(evaluation)를 분리
  * 제어흐름, 상태변화를 특정하지 않고도 로직이 무엇인지 표현식(expression)으로 나타냄
  * 내부 메커니즘은 추상화하고 데이터를 가져오는 SQL 구문도 선언적 프로그래밍의 한 예
  ~~~
  // 앞서 보았던 코드를 선언적 프로그래밍으로 변화시키면 다음과 같다
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(num => Math.pow(num, 2));
  // 람다 표현식을 사용하는 습관을 들이자
  // 람다 표현식은 함수 호출 구조의 가장 중요한 부분만 남기므로 코드를 덜 쓴다
  ~~~
  * 선언적 코드는 루프 제어를 시스템의 다른 파트(Array.map)에 맡기고 각 요소의 처리에만 집중한다
  * 이전 코드와 비교하면 루프 카운터 관리, 정확한 배열 인덱스 접근같은 신경을 쓸 부담이 없다
  * 제어문은 코드가 길어지면 버그 가능성도 높고 함수로 추상하지 않는한 재사용도 안된다
  * 수동 루프를 제거하고 함수를 매개변수로 받는 map, reduce, filter 같은 고계함수를 사용하자
    * 재사용성, 확장성을 획득하는 장점이 있다
    * 앞서 run함수를 이용해 한 일도 같은 맥락에 있다
* 루프를 제거해야 하는 이유
  * 루프는 재사용이 어렵고 다른 연산에 끼워 넣기도 힘든 명령형 제어 구조물
  * 또 성격상 반복할 때마다 값이나 상태를 계속 변경시킨다
  * FP는 무상태성(statelessness)과 불변성(immutability)을 지향한다
  * 무상태코드는 전역 상태를 바꾸거나 혼선을 일으킬 가능성이 없다
  * 상태를 두지 않으려면 부수효과와 상태 변이를 일으키지 않는 순수함수(pure function)를 써야한다

### 1.2.2 순수함수와 부수효과
* 순수함수의 특징
  * 주어진 입력에만 의존해 외부 상태와 무관하게 작동
  * 전역 객체나 참조로 전달된 매개변수를 수정하지 않아 어떤 변경도 일으키지 않음
    ~~~
    var counter = 0;
    function increment() {
      return ++counter;
    }
    ~~~  
    * 위 함수는 자신의 스코프에 없는 counter라는 변수를 변경하므로 불순impure한 함수 
    * 이렇게 외부의 상태를 변경시키면 호출 도중에 어떤 값이 반환될지 알 수 없다
    * 또 다른 흔한 예로 this 키워드로 인스턴스 데이터에 접근하는 것도 부수효과를 유발한다
* 부수효과가 발생하는 상황들
  1. 전역 범위에서 변수, 속성, 자료구조를 변경
  2. 함수의 인자를 변경
  3. 사용자 입력 처리
  4. 예외를 일으킨 해당 함수가 catch하지 않고 바로 throw할 때
  5. 화면 또는 로그파일에 출력
  6. HTML, 브라우저 쿠키, DB에 질의  
* 그러나 실제로 함수형 프로그래밍이 모든 상태 변이를 근절하자는 것은 아니다
  * 객체를 생성, 변경하고 다양한 형태로 출력하는 것은 근본적으로 필요
  * 상태 변이를 줄이고 관리할 수 있는 틀을 제공해 부수효과를 최대한 줄이자는 것 
* 학생 데이터를 관리하는 애플리케이션의 예
  ~~~
  function showStudent(ssn) {
    let student = db.find(ssn);
    if(student !== null) {
      document.querySelector(`#${elementId}`).innerHTML =
      `${student.ssn},
      ${student.firstname},
      ${student.lastname}`;
    } else {
      throw new Error('the student is undefined');
    }
  }

  showStudent('444-44-4444');
  ~~~
  * 이 함수가 일으키고 있는 부수효과들
    * 변수 db를 통해 데이터에 접근하는데 함수에는 이런 매개변수가 없으므로 db는 외부변수이다
    * db가 실행 중 언제라도 null을 참조하거나 호출 단계마다 상이한 값을 가리키면 프로그램의 무결성이 깨질 수 있다
    * elementId는 값이 언제라도 바뀔 수 있는 전역변수라 이 함수가 통제할 방법이 없다
    * HTML을 직접 수정하고 있다. HTML은 그 자체로 가변적인 전역 공유자원이다
    * 학생을 찾지 못해 예외를 던지면 전체 프로그램의 스택이 풀리면서 종료된다 
  * 이렇게 부수효과가 많은 함수는 다루기가 힘들고 테스트도 어렵다
  * 반면 순수함수는 인자에 입력 집합을 전부 명시하므로 코드를 이해하고 사용하기 쉽다
* 앞서 배웠던 내용을 바탕으로 애플리케이션을 개선해보기
  1. 긴 함수를 하나의 목적을 가진 짧은 함수로 분리하기
  2. 함수가 할 일에 필요한 인수를 모두 명시하여 부수효과를 줄이기 
  3. 학생 정보를 조회하는 일과 화면에 그리는 일을 분리하기
  4. 물론 외부 저장소와 DOM에 연동하므로 부수효과는 불가피하나 더 다루기 쉽게 분리는 가능
    ~~~
    var find = curry((db, id) => {
      let obj = db.find(id);
      if(obj === null) {
        throw new Error('객체를 찾을 수 없습니다!');
      }
      return obj;
    });

    var csv = student =>
      `${student.ssn}, ${student.firstname}, ${student.lastname}`;

    var append = curry((selector, info) => {
      document.querySelector(selector).innerHTML = info;
    });
    ~~~ 
    * 재사용 가능한 컴포넌트 3개로 분리되어 유연성 확보
    * 이 함수들을 재사용하면 전체 코드양이 줄어 생산성 제고
    * 해야할 일들을 단계별로 명확하게 보여줘 가독성 확보
    * HTML 객체와 상호작용을 자체 함수로 분리해 불순한 로직을 순수함수에서 배제시킴
    * find 함수에는 예외를 발생시키는 null 체크 분기문이 포함되어 있다
    * 이처럼 함수가 일관된 반환값을 보장해 예측가능성을 높이는 것을 참조 투명성referential transparency이라고 한다
### 1.2.3 참조 투명성과 치환성
* 어떤 함수가 동일한 입력을 받았을 때 동일한 경과를 내면 이는 참조 투명한 함수다
* 앞서 보았던 increment함수는 외부 변수인 counter에 종속되었기 때문에 참조 투명하지 않다
~~~
/* 명령형 */
increment();
increment();
print(counter); // 카운터의 초깃값에 의존하고 호출 도중 변경되면 값을 예상할 수 없다

/* 함수형 */
var plus2 = run(increment, increment);
print(plus2(0)); // 항상 초기값을 2만큼 증가시킴
~~~
* 함수형으로 구축한 프로그램은 시스템의 상태를 예측하기 쉬운 것을 볼 수 있다
~~~
var input = [80, 90, 100];
var sum = (total, current) => total + current;
var total = arr => arr.reduce(sum);
var divide = (a, b) => a / b;
var average = arr => divide(total(arr), size(arr));
average(input);
~~~
  * 부수효과가 있는 함수라면 이런 일이 가능하지 않다
  * 함수 인수를 명확하게 정의하면 스칼라 값을 비롯해 대부분 부수효과를 예방가능하다
  * 객체를 참조로 넘길 때 실수로 이를 변경하지 않도록 주의해야한다
### 1.2.4 불변 데이터 유지하기
* 불변 데이터는 한번 생성된 후에는 절대 바뀌지 않는 데이터다
* 원시 자료형의 값은 처음부터 불변이다
* 하지만 배열 등의 객체는 인자로 넘길때 원래 내용이 변경되어 부수효과가 발생할 소지가 남아있다
  ~~~
  var sortDesc = arr => {
    arr.sort(
      (a, b) => b - a
    );
  };
  ~~~
  * 위 코드는 Array.sort가 원본 레퍼런스를 정렬하는 부수효과를 일으킨다
* 함수형을 앞서 설명한 기본원리들(선언형, 순수함수, 불변성)을 종합해서 정의를 내려보자면 다음과 같다
* #### *외부에서 관찰 가능한 부수효과가 제거된 불변 프로그램을 작성하기 위해 순수함수를 선언적으로 평가하는 것*
### 1.3 함수형 프로그래밍의 좋은 점
### 1.3.1 복잡한 작업을 분해하도록 유도
* 함수형은 분해와 합성 간의 상호작용으로 볼 수 있다
* 이런 양면성 덕분에 함수형은 모듈화가 쉽고 효율적으로 동작한다
* 이 때 모듈화의 단위(작업 단위)는 바로 함수 자신이다
* 앞서 보았던 showStudent 함수는 find, csv, append로 분해되었다
  * 이는 하나의 함수가 한 가지 목표만 가져야 한다는 단일성singularity 원리와 관계가 있다 
* run
  * 합성composition이라는 기법을 구현한 함수
  * 함수의 합성을 수식으로 나타내면 다음과 같다
  * f * g = f(g(x)) => 이를 'f 합성 g'라고 읽는다
  * run을 compose로 바꾼 예제
    ~~~
    var showStudent = compose(append('#student-info'), csv, find(db));
  
    showStudent('444-44-4444');
    ~~~
    * find 함수가 '444-44-4444'를 인자로 받아 반환값을 csv 함수로 넘겨주고 
    * csv 함수가 처리한 결과를 append가 넘겨받아 처리하는 구조다
    * compose는 모듈성과 재사용성을 학습하는 데 매우 중요하다
    * 예제처럼 함수형으로 합성한 코드는 전체 표현식의 의미를 개별 조각에서 추론할 수 있다
    * compose처럼 다른 함수를 인자로 받는 함수를 고계함수higher-order function이라고 한다
### 1.3.2 데이터를 매끄럽게 체이닝하여 처리
* 체인은 같은 객체를 반환하는 순차적인 함수 호출을 말한다
* 체인도 합성처럼 코드를 간결명료하게 작성하게 해주므로 많은 라이브러리에서 사용된다
* 복수 과목을 수강한 학생들의 평균 점수를 계산하는 프로그램
~~~
let enrollment = [
  {enrolled: 2, grade: 100},
  {enrolled: 2, grade: 80},
  {enrolled: 1, grade: 89},
];

var totalGrades = 0;
var totalStudentsFound = 0;
for(let i = 0; i < enrollment.length; i++) {
  let student = enrollment[i];
  if(student !== null) {
    if(student.enrolled > 1) {
      totalGrades += student.grade;
      totalStudentsFound++;
    }
  }
}
var average = totalGrades / totalStudentsFound; // 90
~~~
* 이를 함수형으로 분해하면 세 가지 단계가 필요
  1. 수강 과목이 2개 이상인 자료 집합을 적절히 선택
  2. 학생의 점수를 얻음
  3. 평균 점수를 계산
* Lodash를 사용한 함수 체인으로 해결하기
  ~~~
  _.chain(enrollment)
   .filter(student => student.enrolled > 1)
   .pluck('grade')
   .average()
   .value(); // 90
  ~~~
  * 함수 체인은 필요한 시점까지 실행을 미루는 느긋한 평가lazy evaluation을 수행
  * 이렇게 필요 시 호출call-by-need를 하면 cpu 부하가 줄어들어 성능에도 좋다
  * 물론 위 코드는 실무에서 매우 중요한 에러 처리 코드가 빠져있다
  * 순수 학문적인 함수형 프로그래밍에서는 예외가 없지만 현실에선 완전히 배제하기 힘들다
  * 그렇지만 순수 에러 처리와 예외 처리는 구별해야 한다
  * 따라서 가급적 순수 에러 처리를 하고 정말 예외적인 상황에서만 예외가 나게끔 허용해야 한다
  * 함수형 디자인패턴을 적용하면 표현성의 희생없이도 탄탄한 에러 처리 로직의 구사가 가능하다(5장)
### 1.3.3 복잡한 비동기 애플리케이션에서도 신속하게 반응
* 원격 데이터 조회, 사용자 입력 데이터 처리 등은 자바스크립트에서 매우 중요하다
* 이를 구현하다 보면 콜백 함수가 중첩되어 코드의 선형 흐름이 깨진 더러운 코드를 만들기 쉽다
* 리액티브 프로그래밍은 비동기, 이벤트 로직의 복잡도를 현저하게 줄여 비즈니스 로직에 집중하게 해준다
* 그리고 체이닝, 합성도 가능해 함수형의 능력을 최대화할 수 있다 
* 학생의 SSN을 읽고 검증하는 프로그램 예제
  * 명령형 
  ~~~
  var valid = false;
  var elem = document.querySelector('#student-ssn');
  elem.onkeyup = function(event) {
    var val = elem.value;
    if(val !== null && val.length !== 0) {
      val = val.replace(/^\s*|\s*$|\-s/g, '');
      if(val.length === 9) {
        console.log(`올바른 SSN : ${val}!`);
        valid = true;
      }
    } else {
      console.log(`잘못된 SSN : ${val}!`);
    }
  };
  ~~~
    * 코드의 복잡성도 높고 비즈니스 로직이 집중되어 있어 모듈화도 어렵다
    * 무엇보다 외부 상태에 의존하므로 재사용이 어렵다
  * 함수형
  ~~~
  Rx.Observable.fromEvent(document.querySelector('#student-ssn'), 'keyup')
    .pluck('srcElement', 'value')
    .map(ssn => ssn.replace(/^\s*|\s*$|\-/g, ''))
    .filter(ssn => ssn !== null && ssn.length === 9)
    .subscribe(validSsn => {
      console.log(`올바른 SSN : ${validSsn}!`);
  });
  ~~~
    * 리액티브 패러다임은 옵저버블observable이라는 중요 장치를 매개로 움직인다
    * 이를 이용하면 데이터 스트림을 구독해서 원하는 연산을 합성하고 체이닝할 수 있다
    * 위 코드에서 수행하는 모든 연산은 완전한 불변이다
    * 비즈니스 로직도 개별 함수로 나뉘어있다
  * 물론 함수형이 객체지향 설계와 완전한 대체관계에 있는 것은 아니다
    * 이는 trade-off 관계라기 보다는 적절하게 혼용해 혜택을 보는 관계라고 할 수 있다
### 1.4 마치며
* 순수함수를 사용한 코드는 전역 상태를 바꾸거나 깨뜨릴 일이 전혀 없으므로 테스트, 유지보수가 쉬운 코드를 만든다
* 함수형 프로그래밍은 코드를 선언적으로 작성해 헤아리기 쉽고 가독성도 향상된다(+람다표현식의 깔끔함)
* 여러 원소로 구성된 컬렉션 데이터는 map, reduce 같은 연산의 체인으로 매끄럽게 처리할 수 있다
* 함수형 프로그래밍은 함수를 기본 구성 요소로 취급한다
* 이는 일급/고계함수 개념에 기반을 두며 코드의 모듈성, 재활용성을 높인다
* 리액티브/함수형 프로그래밍을 융합하면 이벤트 기반 프로그램 특유의 복잡성을 줄일 수 있다